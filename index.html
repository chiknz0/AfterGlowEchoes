import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * AFTERGLOW ECHOES - Desktop Edition
 * * Instructions to run:
 * 1. Install Java (JDK) on your computer.
 * 2. Save this file as "AfterglowEchoes.java".
 * 3. Open your terminal/command prompt.
 * 4. Type: javac AfterglowEchoes.java
 * 5. Type: java AfterglowEchoes
 */
public class AfterglowEchoes extends JFrame {
    private static final int WIDTH = 1000;
    private static final int HEIGHT = 800;
    
    public AfterglowEchoes() {
        setTitle("Afterglow Echoes | Digital Salvage");
        setSize(WIDTH, HEIGHT);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
        setResizable(false);
        
        // Hide the standard cursor to show our custom glowing cursor
        setCursor(getToolkit().createCustomCursor(
            new java.awt.image.BufferedImage(1, 1, java.awt.image.BufferedImage.TYPE_INT_ARGB),
            new Point(0, 0), "blank cursor"));
        
        GamePanel panel = new GamePanel();
        add(panel);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            new AfterglowEchoes().setVisible(true);
        });
    }
}

class GamePanel extends JPanel implements ActionListener, MouseListener, MouseMotionListener {
    private enum State { START, PLAYING, LEGENDARY, FINISHED }
    private State gameState = State.START;
    
    private Timer timer;
    private int score = 0;
    private int timeLeft = 60;
    private long lastTick = 0;
    
    private Point mousePos = new Point(0, 0);
    private boolean isPulling = false;
    private int pullOffset = 0;
    private boolean onCooldown = false;
    
    private final Random rand = new Random();
    private final List<PulledItem> activeItems = new CopyOnWriteArrayList<>();
    private PulledItem currentLegendary = null;
    
    // Procedural Generation Tables
    private final String[] PREFIXES = {"Ancient", "Broken", "Holographic", "Cursed", "Radiant", "Glitched", "Neon", "Dusty", "Forgotten", "Stellar", "Rusty", "Digital", "Ghostly", "Hyper", "Shattered", "Void", "Cyber", "Ethereal"};
    private final String[] MATERIALS = {"Quartz", "Iron", "Plasma", "Carbon", "Light", "Silicon", "Gravity", "Aether", "Nuclear", "Memory", "Onyx", "Obsidian"};
    private final String[] OBJECTS = {"Relic", "Drive", "Shard", "Core", "Module", "Tome", "Capsule", "Fragment"};
    private final String[] EMOJIS = {"ðŸ—¿", "ðŸº", "ðŸ’¾", "ðŸ’½", "ðŸ’Ž", "âœ¨", "ðŸ§¿", "ðŸ”®", "ðŸ“¼", "ðŸ“Ÿ", "ðŸ“–", "ðŸ“œ", "ðŸ’Š", "ðŸ§ª", "ðŸ§©", "â˜„ï¸"};

    public GamePanel() {
        setBackground(new Color(2, 2, 5));
        addMouseListener(this);
        addMouseMotionListener(this);
        
        timer = new Timer(16, this); // ~60 FPS animation loop
        timer.start();
        lastTick = System.currentTimeMillis();
    }

    private void performPull() {
        if (gameState != State.PLAYING || onCooldown || isPulling) return;
        
        isPulling = true;
        onCooldown = true;

        new Thread(() -> {
            try {
                // Reach down animation
                for (int i = 0; i <= 100; i += 8) {
                    pullOffset = i;
                    Thread.sleep(15);
                }
                
                // Roll for item
                double roll = rand.nextDouble();
                String name = PREFIXES[rand.nextInt(PREFIXES.length)] + " " + 
                             MATERIALS[rand.nextInt(MATERIALS.length)] + " " + 
                             OBJECTS[rand.nextInt(OBJECTS.length)];
                String emoji = EMOJIS[rand.nextInt(EMOJIS.length)];
                int value = rand.nextInt(2000) + 400;
                boolean isLegendary = roll > 0.985;

                if (isLegendary) {
                    value = 45000;
                    currentLegendary = new PulledItem(name, emoji, value);
                    gameState = State.LEGENDARY;
                    Thread.sleep(3000);
                    score += value;
                    gameState = State.PLAYING;
                } else {
                    score += value;
                    activeItems.add(new PulledItem(name, emoji, value));
                }

                // Pull back up animation
                for (int i = 100; i >= 0; i -= 8) {
                    pullOffset = i;
                    Thread.sleep(15);
                }
                
                isPulling = false;
                Thread.sleep(400); // Gameplay balance delay
                onCooldown = false;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        drawBackground(g2);

        switch (gameState) {
            case START -> drawStartScreen(g2);
            case PLAYING -> drawGame(g2);
            case LEGENDARY -> drawLegendaryScreen(g2);
            case FINISHED -> drawEndScreen(g2);
        }

        drawCursor(g2);
    }

    private void drawBackground(Graphics2D g2) {
        // Deep Space Gradient
        RadialGradientPaint p = new RadialGradientPaint(
            new Point2D.Double(getWidth() * 0.3, getHeight() * 0.4),
            (float) getWidth(),
            new float[]{0f, 0.7f},
            new Color[]{new Color(30, 27, 75, 120), new Color(2, 2, 5, 255)}
        );
        g2.setPaint(p);
        g2.fillRect(0, 0, getWidth(), getHeight());

        // Background Stars
        g2.setColor(new Color(255, 255, 255, 60));
        Random starRand = new Random(42);
        for (int i = 0; i < 120; i++) {
            int x = starRand.nextInt(getWidth());
            int y = starRand.nextInt(getHeight());
            int size = starRand.nextInt(3) + 1;
            g2.fillOval(x, y, size, size);
        }
    }

    private void drawStartScreen(Graphics2D g2) {
        g2.setFont(new Font("Arial", Font.BOLD, 100));
        g2.setColor(Color.WHITE);
        drawCenteredString(g2, "AFTERGLOW", getWidth() / 2, getHeight() / 2 - 50);
        g2.setColor(new Color(21, 94, 117));
        drawCenteredString(g2, "ECHOES", getWidth() / 2, getHeight() / 2 + 50);
        
        g2.setFont(new Font("Arial", Font.PLAIN, 18));
        g2.setColor(Color.GRAY);
        drawCenteredString(g2, "CLICK TO BEGIN THE ARCHIVE SALVAGE", getWidth() / 2, getHeight() / 2 + 150);
    }

    private void drawGame(Graphics2D g2) {
        // Stats Boxes
        g2.setColor(new Color(0, 0, 0, 180));
        g2.fillRoundRect(50, 40, 320, 90, 25, 25);
        g2.fillRoundRect(getWidth() - 370, 40, 320, 90, 25, 25);
        
        g2.setFont(new Font("Monospaced", Font.BOLD, 45));
        g2.setColor(new Color(34, 211, 238));
        g2.drawString("$" + String.format("%,d", score), 75, 100);
        
        g2.setColor(timeLeft < 10 ? Color.PINK : Color.WHITE);
        String timeStr = timeLeft + "s";
        g2.drawString(timeStr, getWidth() - 75 - g2.getFontMetrics().stringWidth(timeStr), 100);

        // Falling Items (Ascending)
        g2.setFont(new Font("SansSerif", Font.PLAIN, 90));
        for (PulledItem item : activeItems) {
            g2.drawString(item.emoji, getWidth() / 2 - 45, item.y);
            item.update();
            if (item.y < -100) activeItems.remove(item);
        }

        // Salvage Chute (The Hole)
        g2.setColor(new Color(15, 23, 42));
        g2.fillOval(getWidth() / 2 - 160, getHeight() - 280, 320, 110);
        g2.setStroke(new BasicStroke(4));
        g2.setColor(new Color(30, 41, 59));
        g2.drawOval(getWidth() / 2 - 160, getHeight() - 280, 320, 110);

        // Mechanical Salvage Arm
        int armY = getHeight() - 280 - 450 + (pullOffset * 4);
        g2.setColor(new Color(71, 85, 105));
        g2.fillRoundRect(getWidth() / 2 - 45, armY, 90, 450, 45, 45);
        
        // Interaction Button
        g2.setColor(onCooldown ? new Color(30, 41, 59) : Color.WHITE);
        g2.fillRoundRect(getWidth() / 2 - 120, getHeight() - 130, 240, 70, 35, 35);
        g2.setColor(onCooldown ? Color.GRAY : Color.BLACK);
        g2.setFont(new Font("Arial", Font.BOLD, 24));
        drawCenteredString(g2, onCooldown ? "SYNCING..." : "REACH", getWidth() / 2, getHeight() - 87);
    }

    private void drawLegendaryScreen(Graphics2D g2) {
        g2.setColor(new Color(2, 2, 5, 230));
        g2.fillRect(0, 0, getWidth(), getHeight());
        
        g2.setFont(new Font("Arial", Font.BOLD, 22));
        g2.setColor(new Color(34, 211, 238));
        drawCenteredString(g2, "--- LEGENDARY ARTIFACT DETECTED ---", getWidth() / 2, getHeight() / 2 - 220);
        
        g2.setFont(new Font("SansSerif", Font.PLAIN, 220));
        drawCenteredString(g2, currentLegendary.emoji, getWidth() / 2, getHeight() / 2 + 50);
        
        g2.setFont(new Font("Arial", Font.BOLD, 45));
        g2.setColor(Color.WHITE);
        drawCenteredString(g2, currentLegendary.name.toUpperCase(), getWidth() / 2, getHeight() / 2 + 180);
    }

    private void drawEndScreen(Graphics2D g2) {
        g2.setFont(new Font("Arial", Font.BOLD, 65));
        g2.setColor(Color.WHITE);
        drawCenteredString(g2, "SHIFT CONCLUDED", getWidth() / 2, getHeight() / 2 - 80);
        
        g2.setFont(new Font("Monospaced", Font.BOLD, 90));
        g2.setColor(new Color(34, 211, 238));
        drawCenteredString(g2, "TOTAL: $" + String.format("%,d", score), getWidth() / 2, getHeight() / 2 + 30);
        
        g2.setFont(new Font("Arial", Font.PLAIN, 22));
        g2.setColor(Color.DARK_GRAY);
        drawCenteredString(g2, "CLICK TO RE-INITIALIZE ARCHIVE", getWidth() / 2, getHeight() / 2 + 160);
    }

    private void drawCursor(Graphics2D g2) {
        g2.setColor(new Color(34, 211, 238, 80));
        g2.fillOval(mousePos.x - 18, mousePos.y - 18, 36, 36);
        g2.setColor(new Color(34, 211, 238));
        g2.fillOval(mousePos.x - 4, mousePos.y - 4, 8, 8);
    }

    private void drawCenteredString(Graphics g, String text, int x, int y) {
        FontMetrics metrics = g.getFontMetrics(g.getFont());
        int adv = metrics.stringWidth(text);
        g.drawString(text, x - adv / 2, y);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        long now = System.currentTimeMillis();
        if (gameState == State.PLAYING && now - lastTick >= 1000) {
            timeLeft--;
            lastTick = now;
            if (timeLeft <= 0) gameState = State.FINISHED;
        }
        repaint();
    }

    public void mousePressed(MouseEvent e) {
        if (gameState == State.START) {
            gameState = State.PLAYING;
            score = 0;
            timeLeft = 60;
        } else if (gameState == State.PLAYING) {
            performPull();
        } else if (gameState == State.FINISHED) {
            gameState = State.START;
        }
    }

    public void mouseMoved(MouseEvent e) { mousePos = e.getPoint(); }
    public void mouseDragged(MouseEvent e) { mousePos = e.getPoint(); }
    
    // Unused mouse events
    public void mouseClicked(MouseEvent e) {}
    public void mouseReleased(MouseEvent e) {}
    public void mouseEntered(MouseEvent e) {}
    public void mouseExited(MouseEvent e) {}

    class PulledItem {
        String name, emoji;
        int value;
        int y;
        double vy = -6.5;

        PulledItem(String name, String emoji, int value) {
            this.name = name; 
            this.emoji = emoji; 
            this.value = value;
            this.y = getHeight() - 280;
        }

        void update() { 
            y += (int) vy;
            vy -= 0.18; // Reverse gravity for floating effect
        }
    }
}
